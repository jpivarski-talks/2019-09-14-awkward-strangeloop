\pdfminorversion=4
\documentclass[aspectratio=169]{beamer}

\mode<presentation>
{
  \usetheme{default}
  \usecolortheme{default}
  \usefonttheme{default}
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
  \setbeamertemplate{footline}[frame number]  % or "page number"
  \setbeamercolor{frametitle}{fg=white}
  \setbeamercolor{footline}{fg=black}
}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{tikz}
\usepackage{courier}
\usepackage{array}
\usepackage{bold-extra}
\usepackage{minted}
\usepackage[thicklines]{cancel}
\usepackage{fancyvrb}

\xdefinecolor{dianablue}{rgb}{0.18,0.24,0.31}
\xdefinecolor{darkblue}{rgb}{0.1,0.1,0.7}
\xdefinecolor{darkgreen}{rgb}{0,0.5,0}
\xdefinecolor{darkgrey}{rgb}{0.35,0.35,0.35}
\xdefinecolor{darkorange}{rgb}{0.8,0.5,0}
\xdefinecolor{darkred}{rgb}{0.7,0,0}
\definecolor{darkgreen}{rgb}{0,0.6,0}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\title[2019-09-14-awkward-strangeloop]{Jagged, ragged, awkward arrays}
\author{Jim Pivarski}
\institute{Princeton University -- IRIS-HEP}
\date{September 14, 2019}

\usetikzlibrary{shapes.callouts}

\begin{document}

\logo{\pgfputat{\pgfxy(0.11, 7.4)}{\pgfbox[right,base]{\tikz{\filldraw[fill=dianablue, draw=none] (0 cm, 0 cm) rectangle (50 cm, 1 cm);}\mbox{\hspace{-8 cm}\includegraphics[height=1 cm]{princeton-logo-long.png}\hspace{0.1 cm}\raisebox{0.1 cm}{\includegraphics[height=0.8 cm]{iris-hep-logo-long.png}}\hspace{0.1 cm}}}}}

\begin{frame}
  \titlepage
\end{frame}

\logo{\pgfputat{\pgfxy(0.11, 7.4)}{\pgfbox[right,base]{\tikz{\filldraw[fill=dianablue, draw=none] (0 cm, 0 cm) rectangle (50 cm, 1 cm);}\mbox{\hspace{-8 cm}\includegraphics[height=1 cm]{princeton-logo.png}\hspace{0.1 cm}\raisebox{0.1 cm}{\includegraphics[height=0.8 cm]{iris-hep-logo.png}}\hspace{0.1 cm}}}}}

% Uncomment these lines for an automatically generated outline.
%\begin{frame}{Outline}
%  \tableofcontents
%\end{frame}

% START START START START START START START START START START START START START

%% \begin{frame}{Motivation: particle physics analysis}
%% \Large
%% \vspace{0.23 cm}
%% \begin{columns}
%% \column{0.5\linewidth}
%% \only<1>{\includegraphics[width=\linewidth]{omega-minus-1.png}}\only<2->{\includegraphics[width=\linewidth]{omega-minus-2.png}}
%% \column{0.5\linewidth}

%% \begin{center}
%% \begin{onlyenv}<1>
%% This is a famous photo: the 1964 discovery of the $\Omega$ baryon.

%% \vspace{1 cm}
%% Do you see it?

%% \vspace{1 cm}
%% \end{onlyenv}\begin{onlyenv}<2>
%% How about now?

%% \begin{align*}
%% K^- + p & \to \Omega^- + K^+ + K^0 \\
%% \Omega^- & \to \Xi^0 + \pi^- \\
%% \Xi^0 & \to \Lambda^0 + \pi^0 \\
%% \Lambda^0 & \to p + \pi^- \\
%% \pi^0 & \to \gamma + \gamma
%% \end{align*}

%% \vspace{1 cm}
%% \end{onlyenv}\begin{onlyenv}<3>
%% This is what particle physicists do: we collide particles, produce new ones and take pictures of their decay chains.

%% \vspace{1 cm}
%% However, these pictures come to us unlabeled: lots of interactions overlap the ``interesting'' ones.

%% \vspace{1 cm}
%% \end{onlyenv}
%% \end{center}

%% \end{columns}
%% \end{frame}

%% \begin{frame}{}
%% \begin{columns}
%% \column{1.15\linewidth}
%% \includegraphics[width=\linewidth]{090324_ALICE-hirez.jpg}
%% \end{columns}
%% \end{frame}

%% \begin{frame}{Then and now}
%% \vspace{0.15 cm}
%% \begin{columns}
%% \column{0.32\linewidth}
%% \includegraphics[width=\linewidth]{H4000010-Team_that_discovered_Omega_minus_particle.jpg}

%% \column{0.5\linewidth}
%% \begin{center}
%% \begin{columns}
%% \column{0.35\linewidth}
%% \centering
%% photographs

%% \vspace{0.5 cm}
%% 100,000 events

%% \vspace{0.5 cm}
%% manual/semi-automated scans

%% \column{0.35\linewidth}
%% \centering
%% digitized signals \\

%% \vspace{0.5 cm}
%% $\sim$trillion events \\

%% \vspace{0.5 cm}
%% algorithmic searches and machine learning
%% \end{columns}
%% \end{center}

%% \column{0.32\linewidth}
%% \includegraphics[width=\linewidth]{cms25_2.jpg}
%% \end{columns}
%% \end{frame}

%% \begin{frame}{Algorithm to identify a particle decay}
%% \large
%% \vspace{0.15 cm}
%% \begin{center}
%% \includegraphics[height=4.2 cm]{kshort-1.png}\hspace{0.1 cm}\includegraphics[height=4.2 cm]{kshort-2.png}\hspace{0.1 cm}\includegraphics[height=4.2 cm]{kshort-3.png}
%% \end{center}

%% \vspace{0.15 cm}
%% \begin{enumerate}
%% \item Loop over all pairs of particle tracks, tentatively labeling them $\pi^+$ and $\pi^-$.
%% \item Calculate m = $\sqrt{(E_{\pi^+} + E_{\pi^-})^2 - \left|\vec{p}_{\pi^+} + \vec{p}_{\pi^-}\right|^2}$.
%% \item The ones with $m \sim \mbox{mass}({K_s^0}) = 0.5\mbox{ GeV}/c^2$ are good candidates.
%% \end{enumerate}
%% \end{frame}

%% \begin{frame}{Apply successively down the decay chain}
%% \Large
%% \begin{center}
%% $H \to ZZ$\hspace{1 cm}$Z \to e^+e^-$\hspace{1 cm}$Z \to \mu^+\mu^-$
%% \end{center}

%% \includegraphics[height=6 cm]{higgs-to-four-leptons.png}\hfill\includegraphics[height=6 cm]{higgs-to-four-leptons-2.png}
%% \end{frame}

%% \begin{frame}{Key parts of the calculation}
%% \Large
%% \vspace{0.15 cm}
%% \begin{itemize}\setlength{\itemsep}{0.25 cm}
%% \item All events are independent; no particles or decays cross from one event to the next.
%% \item Detectors produce collections of different kinds of signals: tracks, energy deposition, timing\ldots
%% \item Candidates are generated with a \mintinline{sql}{SELF JOIN} (items from the same collection) or a \mintinline{sql}{CROSS JOIN} (items from different collections) \mintinline{sql}{ON t1.eventId == t2.eventId}.
%% \item Good candidates are identified by {\it filtering} (throw away the bad) and/or {\it reduction} (pick the best of what remains.)
%% \end{itemize}
%% \end{frame}

%% \begin{frame}{Key parts of the calculation}
%% \Large
%% \vspace{0.5 cm}
%% \includegraphics[width=\linewidth]{explode-flat-reduce.pdf}

%% \hfill \ldots independently for each event.
%% \end{frame}

%% \begin{frame}{Key part of the data structure}
%% \Large
%% \vspace{0.25 cm}
%% \begin{itemize}
%% \item Large number of events, processed in parallel.
%% \item Each event has an {\it arbitrary number} of record structures.
%% \item Not reducible to a flat table without padding and/or loss.
%% \end{itemize}

%% \vspace{0.25 cm}
%% \begin{columns}
%% \column{0.5\linewidth}
%% \includegraphics[width=\linewidth]{muons-as-objects.png}

%% \column{0.5\linewidth}
%% \includegraphics[width=\linewidth]{muons-as-a-table.png}
%% \end{columns}
%% \end{frame}

%% \begin{frame}{Programming languages used in particle physics}
%% \large
%% \vspace{0.5 cm}
%% \includegraphics[width=\linewidth]{programming-languages.pdf}

%% \vspace{0.25 cm}
%% \begin{itemize}
%% \item First programmable computers were used for particle physics simulations.
%% \item Fortran was used to analyze events soon after the language was invented.
%% \item Major transition from Fortran to C++ in the late 1990's/early 2000's.
%% \item Very recent adoption of Python (alongside C++).
%% \end{itemize}
%% \end{frame}

%% \begin{frame}{The Python transition}
%% \vspace{0.2 cm}
%% \includegraphics[width=\linewidth]{github-cmssw-lin.pdf}

%% \includegraphics[width=\linewidth]{github-cmssw-frac.pdf}
%% \end{frame}

%% \begin{frame}[fragile]{In our field, ``conventional'' analysis means C++}
%% \vspace{0.25 cm}
%% \begin{columns}[b]
%% \column{0.7\linewidth}
%% \begin{minted}{c++}
%% std::vector<Kaon*> getKaons(Event event) {
%%   std::vector<Track*> tracks = event.getTracks();
%%   std::vector<Kaon*> kaons;
%%   for (auto t1 = tracks.begin(); t1 != tracks.end(); ++t1) {
%%     for (auto t2 = t1 + 1; t2 != tracks.end(); ++t2) {
%%       if (t1->charge != t2->charge) {
%%         double m = mass(t1, t2);
%%         if (fabs(m - 0.5) < 0.01) {
%%           kaons.push_back(new Kaon(t1, t2));
%%         }
%%       }
%%     }
%%   }
%%   return kaons;
%% }
%% \end{minted}

%% \vspace{0.1 cm}

%% \column{0.25\linewidth}
%% \includegraphics[width=\linewidth]{kshort-1.png}
%% \end{columns}
%% \end{frame}

%% \begin{frame}[fragile]{Direct translation to Python would be a performance disaster}
%% \vspace{0.25 cm}
%% \begin{columns}[b]
%% \column{0.7\linewidth}
%% \begin{minted}[stripnl=false]{python}
%% def getKaons(event):
%%   tracks = event.getTracks()
%%   kaons = []
%%   for i, t1 in enumerate(tracks):
%%     for t2 in tracks[i + 1:]:
%%       if t1.charge != t2.charge:
%%         m = mass(t1, t2)
%%         if abs(m - 0.5) < 0.01:
%%           kaons.append(Kaon(t1, t2))




%%   return kaons

%% \end{minted}

%% \vspace{0.1 cm}

%% \column{0.25\linewidth}
%% \includegraphics[width=\linewidth]{kshort-1.png}
%% \end{columns}
%% \end{frame}

%% \begin{frame}{High-throughput data analysis is based on Numpy}
%% \vspace{0.5 cm}
%% \begin{center}
%% \includegraphics[width=0.35\linewidth]{numpy-logo.png}

%% \vspace{1 cm}
%% \includegraphics[width=0.75\linewidth]{numpy-memory-layout.png}
%% \end{center}
%% \end{frame}

%% \begin{frame}{High-throughput data analysis is based on Numpy}
%% \Large
%% \vspace{0.5 cm}
%% \begin{columns}
%% \column{0.4\linewidth}
%% \includegraphics[width=\linewidth]{numpy-slicing.png}

%% \column{0.52\linewidth}
%% Numpy has a suite of operations that each apply to whole arrays (compiled, maybe vectorized loop).

%% \vspace{1 cm}

%% By manipulating the {\tt shape} and {\tt strides}, slices are $\mathcal{O}(1)$ and zero-copy.
%% \end{columns}
%% \end{frame}

%% \begin{frame}{But Numpy doesn't have a construct for variable-length lists}
%% \Large
%% \vspace{0.5 cm}
%% \includegraphics[width=\linewidth]{two-collections.pdf}

%% \vspace{0.5 cm}
%% \uncover<2->{Arrays of variable-length subarrays are sometimes called ``jagged`` or ``ragged`` arrays.}
%% \end{frame}

\begin{frame}{}
\LARGE
\vspace{1 cm}
HERE's the part that didn't get pushed.

\vspace{1 cm}
It shows jagged arrays in terms of counts, offsets, starts/stops, and parents.
\end{frame}

\begin{frame}{Properties of this representation}
\Large
\vspace{0.5 cm}
\begin{itemize}\setlength{\itemsep}{0.5 cm}
\item<1-> Data structures are {\it fully composable:} a jagged array's content can be another jagged array, some fields of a record structure can be jagged, others not.
\item<2-> Most operations (such as slicing) can modify the structure ({\tt counts}/{\tt offsets}/{\tt starts,stops}/{\tt parents}) without touching the content.

\vspace{0.25 cm}
\uncover<3->{\textcolor{gray}{(For instance, the content can be lazily loaded\ldots)}}
\end{itemize}
\end{frame}

\begin{frame}{Example: generate distinct muon pairs}
\vspace{0.2 cm}

\begin{columns}
\column{1.1\linewidth}

{\large\bf muons:}

\vspace{0.2 cm}
\begin{tabular}{r l}
%% \textcolor{red}{counts}  & \textcolor{red}{\tt \ \ \ \ \ 3,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 1,\ \ \ \ \ \ 1,\ \ \ \ \ \ 2\ \ \ \ \ \ \ \ \ } \\
\textcolor{red}{offsets} & \textcolor{red}{\tt \ \ \ \ \ 0,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 3,\ \ \ \ \ \ 4,\ \ \ \ \ \ 5,\ \ \ \ \ \ \ 7} \\
%% \textcolor{red}{starts}  & \textcolor{red}{\tt \ \ \ \ \ 0,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 3,\ \ \ \ \ \ 4,\ \ \ \ \ \ 5\ \ \ \ \ \ \ \ \ } \\
%% \textcolor{red}{stops}   & \textcolor{red}{\tt \ \ \ \ \ 3,\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 4,\ \ \ \ \ \ 5,\ \ \ \ \ \ 7\ \ \ \ \ \ \ \ \ } \\
\mbox{\hspace{1 cm}$p_T$} & \textcolor{darkgreen}{\tt \ \ 31.1,\ \ \ 9.76,\ \ \ 8.18,\ \ \ 5.27,\ \ \ 4.72,\ \ \ 8.59, 8.714} \\
phi &  \textcolor{darkorange}{\tt -0.481,\ -0.123,\ -0.119,\ \ 1.246,\ -0.207,\ -1.754,\ 0.185} \\
eta &        \textcolor{blue}{\tt \ 0.882,\ \ 0.924,\ \ 0.923,\ -0.991,\ \ 0.953,\ -0.264,\ 0.629} \\
\end{tabular}

\vspace{0.6 cm}
{\large\bf muons.choose(2):}

\vspace{0.2 cm}
\begin{tabular}{r l}
%% \textcolor{red}{counts}  &   \textcolor{red}{\tt 3,\ \ \ \ \ \ \ 0,\ 0,\ 1} \\
\textcolor{red}{offsets} &   \textcolor{red}{\tt 0,\ \ \ \ \ \ \ 2,\ 2,\ 2,\ 3} \\
\textcolor{black}{left}  & \textcolor{black}{\tt 0,\ 0,\ 1,\ \ \ \ \ \ \ 5} \\
\textcolor{black}{right} & \textcolor{black}{\tt 1,\ 2,\ 2,\ \ \ \ \ \ \ 6} \\
\textcolor{black}{left.content}  & \textcolor{black}{muons} \\
\textcolor{black}{right.content} & \textcolor{black}{muons} \\
\end{tabular}

\vspace{-3.2 cm}
\uncover<2->{\hfill\includegraphics[height=3.5 cm]{muons-choose-2.pdf}}

\vspace{0.2 cm}
\uncover<3->{\textcolor{gray}{(The ``left'' and ``right'' of each pair is a link to the original muons.)}}
\end{columns}
\end{frame}

%% \begin{frame}[fragile]{As a data structure}
%% \vspace{0.25 cm}
%% \begin{columns}
%% \column{1.08\linewidth}
%% \scriptsize
%% \begin{verbatim}
%% muons =
%%     ListArray(
%%         offsets = [0, 3, 4, 5, 7],
%%         content =
%%             RecordArray(
%%                  pT = numpy.array([  31.1,   9.76,   8.18,   5.27,   4.72,   8.59, 8.714]),
%%                 eta = numpy.array([-0.481, -0.123, -0.119,  1.246, -0.207, -1.754, 0.185]),
%%                 phi = numpy.array([ 0.882,  0.924,  0.923, -0.991,  0.953, -0.264, 0.629])))



%% muons.choose(2) =
%%     ListArray(
%%         offsets = [0, 2, 2, 2, 3],
%%         content =
%%             RecordArray(
%%                  left = IndirectArray(index = [0, 0, 1, 5], content = muons)
%%                 right = IndirectArray(index = [1, 2, 2, 6], content = muons)))
%% \end{verbatim}
%% \end{columns}
%% \end{frame}

\begin{frame}[fragile]{Awkward Array: data structures with a Numpy-like API}
\small
\hfill\includegraphics[height=2 cm]{awkward-logo.pdf}

\vspace{-2 cm}
\begin{minted}{python}
>>> import awkward
>>> array = awkward.fromiter(
...     [[1.1, 2.2, None, 3.3, None],
...      [4.4, [5.5]],
...      [{"x": 6, "y": {"z": 7}}, None, {"x": 8, "y": {"z": 9}}]])
\end{minted}

\begin{uncoverenv}<2->
\begin{minted}{python}
>>> print(array)            # internally, these are all arrays
[[1.1 2.2 None 3.3 None] [4.4 [5.5]] [<Row 0> None <Row 1>]]
\end{minted}
\end{uncoverenv}

\begin{uncoverenv}<3->
\begin{minted}{python}
>>> print(array[:, -2:])    # all of outer list, last two of inner
[[3.3 None] [4.4 [5.5]] [None <Row 1>]]
\end{minted}
\end{uncoverenv}

\begin{uncoverenv}<4->
\begin{minted}{python}
>>> (array + 100).tolist()  # element-wise function applied to arrays
[[101.1, 102.2, None, 103.3, None],
 [104.4, [105.5]],
 [{'x': 106, 'y': {'z': 107}}, None, {'x': 108, 'y': {'z': 109}}]]
\end{minted}
\end{uncoverenv}
\end{frame}

\begin{frame}[fragile]{Structure is as deep as the {\it data type,} not the {\it data}}
\begin{columns}
\column{1.1\linewidth}
\scriptsize
\begin{minted}{python}
>>> array.layout
 layout 
[           ()] JaggedArray(starts=layout[0], stops=layout[1], content=layout[2])
[            0]   ndarray(shape=3, dtype=dtype('int64'))
[            1]   ndarray(shape=3, dtype=dtype('int64'))
[            2]   IndexedMaskedArray(mask=layout[2, 0], content=layout[2, 1], maskedwhen=-1)
[         2, 0]     ndarray(shape=10, dtype=dtype('int64'))
[         2, 1]     UnionArray(tags=layout[2, 1, 0], index=layout[2, 1, 1],
                               contents=[layout[2, 1, 2], layout[2, 1, 3], layout[2, 1, 4]])
[      2, 1, 0]       ndarray(shape=7, dtype=dtype('uint8'))
[      2, 1, 1]       ndarray(shape=7, dtype=dtype('int64'))
[      2, 1, 2]       ndarray(shape=4, dtype=dtype('float64'))
[      2, 1, 3]       JaggedArray(starts=layout[2, 1, 3, 0], stops=layout[2, 1, 3, 1],
                                  content=layout[2, 1, 3, 2])
[   2, 1, 3, 0]         ndarray(shape=1, dtype=dtype('int64'))
[   2, 1, 3, 1]         ndarray(shape=1, dtype=dtype('int64'))
[   2, 1, 3, 2]         ndarray(shape=1, dtype=dtype('float64'))
[      2, 1, 4]       Table(x=layout[2, 1, 4, 0], y=layout[2, 1, 4, 1])
[   2, 1, 4, 0]         ndarray(shape=2, dtype=dtype('int64'))
[   2, 1, 4, 1]         Table(z=layout[2, 1, 4, 1, 0])
[2, 1, 4, 1, 0]           ndarray(shape=2, dtype=dtype('int64'))
\end{minted}
\end{columns}
\end{frame}

\begin{frame}[fragile]{High-level type is defined by what \mintinline{python}{f[x]} returns}
\small
\begin{minted}{python}
>>> print(array.type)
[0, 3) -> [0, inf) -> ?((float64             |
                         [0, inf) -> float64 |
                         'x' -> int64
                         'y' -> 'z' -> int64 ))
\end{minted}

\normalsize
\vspace{0.5 cm}
{\bf That is,}
\begin{itemize}
\item first square bracket in \mintinline{python}{array[x]} takes a non-negative integer less than 3;
\item second takes a non-negative integer (unknown upper limit because it's jagged);
\item what that returns is nullable (might be \mintinline{python}{None});
\item and it could be a \mintinline{python}{float}, a jagged array of floats, or a record taking \mintinline{python}{'x'} or \mintinline{python}{'y'};
\item \mintinline{python}{'x'} returns an integer; \mintinline{python}{'y'} returns another record taking \mintinline{python}{'z'} to integers.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{A more realistic example}
\begin{columns}
\column{1.07\linewidth}
\small
\begin{minted}{python}
>>> import urllib.request
>>> stars = awkward.fromiter(
...     json.load(
...         urllib.request.urlopen(
...            "http://scikit-hep.org/uproot/examples/exoplanets.json")))
>>> stars
<Table [<Row 0> <Row 1> <Row 2> ... <Row 2933> <Row 2934>]>
\end{minted}

\begin{onlyenv}<1>
\vspace{10 cm}
\end{onlyenv}
\begin{onlyenv}<2>
\begin{minted}{python}
>>> fixit(stars[8])
{'name': '24 Sex', 'ra': 155.86821, 'dec': -0.902244, 'dist': 72.21,
 'mass': 1.54, 'radius': 4.9, 'planets': [
     {'name': 'b', 'orbit': 1.333, 'eccen': 0.09, 'period': 452.8,
      'mass': 1.99, 'radius': None},
     {'name': 'c', 'orbit': 2.08, 'eccen': 0.29, 'period': 883.0,
      'mass': 0.86, 'radius': None}]}
\end{minted}

\vspace{10 cm}
\end{onlyenv}
\begin{onlyenv}<3>
\scriptsize
\vspace{-0.35 cm}
\begin{verbatim}
>>> print(stars.type)
[0, 2935) -> 'name'    -> <class 'str'>
             'ra'      -> float64
             'dec'     -> float64
             'dist'    -> ?(float64)
             'mass'    -> ?(float64)
             'radius'  -> ?(float64)
             'planets' -> [0, inf) -> 'eccen'  -> ?(float64)
                                      'mass'   -> ?(float64)
                                      'name'   -> <class 'str'>
                                      'orbit'  -> ?(float64)
                                      'period' -> ?(float64)
                                      'radius' -> ?(float64)
\end{verbatim}
\end{onlyenv}
\end{columns}
\end{frame}








\begin{frame}{}
\end{frame}

\end{document}
